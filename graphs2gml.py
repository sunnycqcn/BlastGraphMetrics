#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Thu Mar  6 21:20:18 2014

@author: tgibbons
"""


import sys
import argparse
import re

import networkx as nx


def main(argv=None):
    """Where the magic happens!

    The main() function coordinates calls to all of the other functions in this
    program in the hope that, by their powers combined, useful work will be
    done.

    Args:
        None

    Returns:
        An exit status (hopefully 0)
    """
    if argv is None:
        argv = sys.argv

    args = get_parsed_args()

    MG = nx.MultiGraph()

    # Add comprehensive list of nodes to graph from original BLAST file
    get_nodes_from_blast(MG=MG, blast=args.blast, bscol=args.bscol,
                         qlcol=args.qlcol, idchar=args.idchar)

    # Add edges present in the various graphs output by blast2graph.py
    for graph_handle in args.graphs:
        add_edges_from_graph(MG=MG, graph_handle=graph_handle)

    # Add edges between nodes that co-clustered in at least one MCL clustering
    for mcl_file in args.clusterings:
        mcl_handle = open(mcl_file)
        add_edges_from_clustering(MG=MG, mcl_handle=mcl_handle)
        mcl_handle.close()

    # Print one or more network files to be viewed in Cytoscape and/or Gephi
    prefix = str(args.out_pref)
    if args.compress:
        suffix = '.'+str(args.compress)
    else:
        suffix = ''

    nx.write_gml(MG, prefix+'.gml'+suffix)
    if args.gexf:
        nx.write_gexf(MG, prefix+'.gexf'+suffix)
    if args.graphml:
        nx.write_graphml(MG, prefix+'.graphml'+suffix)


def get_parsed_args():
    """Parse the command line arguments

    Parses command line arguments using the argparse package, which is a
    standard Python module starting with version 2.7.

    Parameters
    ----------
    None, argparse fetches them from user input

    Returns
    -------
    args : argparse.Namespace object
        Contains the parsed command line arguments
    """
    parser = argparse.ArgumentParser(
        description="")

    parser.add_argument('--out_pref', dest='out_pref',
                        help="Prefix for output file(s)")
    parser.add_argument('--gexf', dest='gexf', default=False,
                        action='store_true',
                        help="Print GEXF file in addition to the GML file")
    parser.add_argument('--graphml', dest='graphml', default=False,
                        action='store_true',
                        help="Print GraphML file in addition to the GML file")
    parser.add_argument('--compress', dest='compress', default=None,
                        help="Compress output files using either the gzip " +
                             "'gz' or bzip2 'bz2' compression algorithm " +
                             "[def=None]")
    parser.add_argument('--blast', dest='blast',
                        type=argparse.FileType('r'),
                        help="BLASTp file containing self hits for every " +
                             "node in the graph")
    parser.add_argument('--graphs', dest='graphs', nargs='+',
                        type=argparse.FileType('r'),
                        help="'abc' graphs like those produced by the " +
                             "blast2graph.py program")
    parser.add_argument('--clusterings', dest='clusterings', nargs='+',
                        help="Clusterings generated by MCL. In order to " +
                             "more easily support a very large number of " +
                             "clusterings, I do not pre-validate that each " +
                             "clustering file is actually a readable text " +
                             "file.")
    parser.add_argument('--bscol', dest='bscol', type=int, default=12,
                        help="One-indexed column containing pairwise bit " +
                             "scores (not required if files include " +
                             "standard header lines) [def=12]")
    parser.add_argument('--qlcol', dest='qlcol', type=int, default=13,
                        help="One-indexed column containing query lengths " +
                             "(not required if files include standard " +
                             "header lines) [def=13]")
    parser.add_argument('--idchar', dest='idchar', default='|',
                        help="The character used to separate the organism " +
                             "ID from the rest of the sequence ID [def='|']")

    args = parser.parse_args()

    return args


def get_nodes_from_blast(MG, blast, bscol, qlcol, idchar):
    """Store sequence information from BLAST file in NetworkX graph
    """
    for line in blast:
        temp = line.strip().split()
        if not temp:
            continue
        elif temp[0][0] == "#":
            continue

        if temp[0] == temp[1]:
            seq_id = str(temp[0])
            bit_scr = float(temp[bscol])
            seq_len = int(temp[qlcol])
            org_id = seq_id.split(idchar)[0]
            try:
                kog_id = re.search('KOG\d{4}', seq_id).group()
            except AttributeError:
                kog_id = None

            MG.add_node(seq_id, {'len': seq_len, 'sbs': bit_scr,
                                 'org': org_id, 'kog': kog_id})


def add_edges_from_graph(MG, graph_handle):
    """
    """
    metric = get_metric_from_filename(graph_handle.name)
    for line in graph_handle:
        temp = line.strip().split()
        if not temp:
            continue
        u = str(temp[0])
        v = str(temp[1])
        w = float(temp[2])

        try:
            MG[u][v][0][metric] = w

        except KeyError:
            org_match = False
            if MG.node[u]['org'] == MG.node[v]['org']:
                org_match = True

            kog_match = False
            if MG.node[u]['kog'] == MG.node[v]['kog']:
                kog_match = True

            MG.add_edge(u, v, attr_dict={metric: w, 'interaction': 'graph',
                                         'Org_match': org_match,
                                         'KOG_match': kog_match})


def get_metric_from_filename(filename):
    """
    """
    # Identify metric used to weight graph
    if re.search('_nle', filename):
        return 'nle'
    elif re.search('_bit', filename):
        return 'bit'
    elif re.search('_bsr', filename):
        return 'bsr'
    elif re.search('_bal', filename):
        return 'bal'
    else:
        raise Exception(
            "Could not determine metric used for file "+filename+". Make " +
            "sure file names contain one of '_bit', '_bsr', '_bal', or " +
            "'_nle'.")


def add_edges_from_clustering(MG, mcl_handle):
    """
    """
    metric = get_metric_from_filename(mcl_handle.name)
    for cluster in mcl_handle:
        seqs = cluster.strip().split()
        for u in seqs:
            for v in seqs:
                if u == v:
                    break
                else:
                    try:
                        MG[u][v][1][metric] += 1

                    except KeyError:
                        try:
                            MG[u][v][1][metric] = 1

                        except KeyError:
                            org_match = False
                            if MG.node[u]['org'] == MG.node[v]['org']:
                                org_match = True

                            kog_match = False
                            if MG.node[u]['kog'] == MG.node[v]['kog']:
                                kog_match = True

                            MG.add_edge(u, v,
                                        attr_dict={metric: 1,
                                                   'interaction': 'cluster',
                                                   'Org_match': org_match,
                                                   'KOG_match': kog_match})


if __name__ == "__main__":
    sys.exit(main())
